# Aparna Radhakrishnan 08/04/2014
WriteNC <-  function(filename,data.array,var.name,xlon,ylat,prec='double', missval=1.e20,
                     time.index.start=NA, time.index.end=NA, downscale.tseries=NA, downscale.origin=NA,
                     start.year="undefined",units ,calendar='irrelevant',lname=var.name,cfname=var.name, 
                     bounds=FALSE, bnds.list=NA, var.data=NA) {
  #'Creates file filename (netCDF type) with the variable  var.name along with the 
  #'coordinate variables in the netCDF file, CF standard name, long names.
  #'
  #'@param filename: The name under which the data will be written
  #' -----Parameters related to the NetCDF varaible-----
  #'@param data.array: The array containing the values of the variable to 
  #'be written to file. 
  #'@param var.name: The short name of the NetCDF variable being written. In the
  #'current FUDGE driver, picked up from the input var list.
  #'@param units: The units of the NetCDF variable. In the current FUDGE driver, 
  #'obtained by CFChecker
  #'@param lname: The long name of the NetCDF variable being written. In the current 
  #'FUDGE driver, generated by CF.R
  #'@param cfname: The CF-standard-compliant name of the variable being written.
  #'Currently obtained from CF.R, and defaults to var.name.
  #' ------Parameters related to the dimensions of the new NetCDF file----
  #'Note: at present, all time-related coordinates are obtained from the 
  #'time windowing mask file specified as the future predictor, and all 
  #'space-related coordinates are obtained from the spatial mask specified
  #'for the region.
  #'@param xlon, ylat : The longitude and latitude dimensions of the
  #'input data, cloned in their entiretly from the target netCDF file
  #'  --Used to get time data directly from the time masks:
  #'@param downscale.tseries: The entire time dimension of the input future predictor
  #'or esd.gen dataset, cloned from the input file. 
  #'@param downscale.origin: The origin from which downscale.tseries is calculated,
  #'in 'days since..." format. 
  #'@param calendar: The calendar of the timeseries.
  #' --Used to construct time data from the inputs
  #'@param start.year: Altername method for determining the origin 
  #'@param time.index.start: first time index from which to count. Defaults to 0.
  #'@param time.index.end: time index to count to. Defaults to 1. 
  #'--Used to create the bounds variables and offsets 
  #'--(neccesary if to be looked at in Ferret)
  #'@param bounds=FALSE: Whether or not to attempt consruction of bounds parameters. 
  #'Defaults to FALSE.
  #'@param bnds.list=NA : The list of bounds values and other parameters to be used
  #'in constructing a variable. Currently cloned from the input mask files; defaults to 
  #'NA if no list is provided. 
  #'
  #'TODO: Check on the missing values for the non-downscaled vars. 
  #'Are they CF-compliant? And if not, how do we deal with the int/double prec. issue?
    
    FUDGEROOT = Sys.getenv(c("FUDGEROOT"))
    
    #' If CFNAME undefined in the call, pull information from CF.R. Use default otherwise. 
    print(cfname)
    if(cfname == var.name){
      ###CEW comment: should be sourced from calls in driver script
      #    source(paste(FUDGEROOT,"Rsuite/FudgeIO/src/","CF.R",sep=""))
      cflist <- GetCFName(var.name)
      if(is.list(cflist)){     ###CEW: Changed because was throwing a warning when cflist != "none"
        cfname <- cflist$cfname
        lname <- cflist$cflongname
        print(paste("cfname:",cfname,sep=''))
      }else{
        print("CF.R does not contain this variable. Using default values")
      }
    }
    
    #Define variable list and populate it
    var.dat <- list()    
    #Write the variable containing downscaled data
    if(exists("xlon") & (xlon[1] != '')){
      var.dat[[var.name]] <- ncvar_def(var.name,units,list(xlon,ylat,downscale.tseries),missval=missval,longname=lname,prec=prec)#x,y,t1
    }else{
      var.dat[[var.name]] <- ncvar_def(var.name,units,list(ylat, downscale.tseries),missval=missval,longname=lname,prec=prec, verbose=TRUE)
    }
    #1-5 alternate structure
    bnds <- ncdim_def("bnds", "", c(1,2))
    for (v in 1:length(var.data)){
      var <- names(var.data)[v]
      message(paste("defining var", var))
      var.dim <- unlist(strsplit(attr(var.data[[v]], "dimids"), ","))
      var.dimlist <- list()
      #if(is.null(var.dim)){
      if(var.dim[1]=='NA'){
        var.dimlist <- NULL
      }else{
        for(d in 1:length(var.dim)){
          print(d)
          print(var.dim[[d]]) #Blame R's need to return all functions as elements of a list.
          var.dimlist[[d]] <- switch(as.character(var.dim[d]), 
                                     "bnds"=bnds, 
                                     "lon"=xlon, 
                                     "lat"=ylat, 
                                     "time"=downscale.tseries) #There should probably be an error here, but not sure what it would be
        }
      }
      var.dat[[var]] <- ncvar_def(var, #var.data[[v]], #Don't forget to add the data in somewhere 
                                  units=attr(var.data[[var]], "units"), #Add check for adding units back in if not present
                                  #units="",
                                  dim=var.dimlist, 
                                  missval=as.numeric(attr(var.data[[var]], "missval") ), #Add check for this as well. 
                                  longname = attr(var.data[[var]], "longname"), 
                                  prec = attr(var.data[[var]], "prec") #This oen gave me hives last time.
                                  )
    }
    print(length(var.dat))
    #save('var.dat', file="/home/cew/Code/testing/ncvars.out")
    message("creating nc objects")
    nc.obj <- nc_create(filename, var.dat)
    message("placing nc vars")
    ncvar_put(nc.obj, var.dat[[var.name]], data.array)
    for (v in 1:length(var.data)){
      loop.var <- names(var.data)[[v]]
      message(paste("adding", loop.var, "and attributes"))
      ncvar_put(nc.obj, var.dat[[loop.var]], var.data[[loop.var]])
      all.att.list <- attributes(var.data[[loop.var]])
      all.att.list <- all.att.list[!(names(all.att.list)%in% c("units", "missval", "longname", "prec", "dim", "dimids"))]
      if(length(all.att.list) > 0){
        for (at in 1:length(all.att.list)){
          ncatt_put(nc.obj, loop.var,  names(all.att.list)[[at]], all.att.list[[at]])
        }
      }
    }   
    #Link axes to the dimensions
    ncatt_put(nc.obj,"time","axis",'T')
    ncatt_put(nc.obj,"lat","axis",'Y')
    ncatt_put(nc.obj,"lon","axis",'X')

      #Link bounds variables to the corresponding dims
      ncatt_put(nc.obj, "lat", 'bounds', 'lat_bnds')
      ncatt_put(nc.obj, "lon", 'bounds', 'lon_bnds')
      ncatt_put(nc.obj, "time", 'bounds', 'time_bnds')
    #And establish long names in the code
    ncatt_put(nc.obj,"time","standard_name","time")
    ncatt_put(nc.obj, "time", "long_name", "time")
    ncatt_put(nc.obj,"lat","standard_name","latitude")
    ncatt_put(nc.obj,"lat","long_name","latitude")
    ncatt_put(nc.obj,"lon","standard_name","longitude")
    ncatt_put(nc.obj,"lon","long_name","longitude")
    ncatt_put(nc.obj,var.dat[[var.name]],"units",units)
    ncatt_put(nc.obj,var.dat[[var.name]],"standard_name",cfname)
    ########### write grid coordinate bounds ####################
    
    #############################################################  
    nc_close(nc.obj)
    return(filename)
}
