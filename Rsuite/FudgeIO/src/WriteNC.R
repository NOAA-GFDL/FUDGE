# Aparna Radhakrishnan 08/04/2014
WriteNC <-  function(filename,data.array,var.name,xlon,ylat,prec='double', missval=1.e20,
                     time.index.start=NA, time.index.end=NA, downscale.tseries=NA, downscale.origin=NA,
                     start.year="undefined",units ,calendar='irrelevant',lname=var.name,cfname=var.name, 
                     bounds=FALSE, bnds.list=NA, var.data=NA) {
  #'Creates file filename (netCDF type) with the variable  var.name along with the 
  #'coordinate variables in the netCDF file, CF standard name, long names.
  #'
  #'@param filename: The name under which the data will be written
  #' -----Parameters related to the NetCDF varaible-----
  #'@param data.array: The array containing the values of the variable to 
  #'be written to file. 
  #'@param var.name: The short name of the NetCDF variable being written. In the
  #'current FUDGE driver, picked up from the input var list.
  #'@param units: The units of the NetCDF variable. In the current FUDGE driver, 
  #'obtained by CFChecker
  #'@param lname: The long name of the NetCDF variable being written. In the current 
  #'FUDGE driver, generated by CF.R
  #'@param cfname: The CF-standard-compliant name of the variable being written.
  #'Currently obtained from CF.R, and defaults to var.name.
  #' ------Parameters related to the dimensions of the new NetCDF file----
  #'Note: at present, all time-related coordinates are obtained from the 
  #'time windowing mask file specified as the future predictor, and all 
  #'space-related coordinates are obtained from the spatial mask specified
  #'for the region.
  #'@param xlon, ylat : The longitude and latitude dimensions of the
  #'input data, cloned in their entiretly from the target netCDF file
  #'  --Used to get time data directly from the time masks:
  #'@param downscale.tseries: The entire time dimension of the input future predictor
  #'or esd.gen dataset, cloned from the input file. 
  #'@param downscale.origin: The origin from which downscale.tseries is calculated,
  #'in 'days since..." format. 
  #'@param calendar: The calendar of the timeseries.
  #' --Used to construct time data from the inputs
  #'@param start.year: Altername method for determining the origin 
  #'@param time.index.start: first time index from which to count. Defaults to 0.
  #'@param time.index.end: time index to count to. Defaults to 1. 
  #'--Used to create the bounds variables and offsets 
  #'--(neccesary if to be looked at in Ferret)
  #'@param bounds=FALSE: Whether or not to attempt consruction of bounds parameters. 
  #'Defaults to FALSE.
  #'@param bnds.list=NA : The list of bounds values and other parameters to be used
  #'in constructing a variable. Currently cloned from the input mask files; defaults to 
  #'NA if no list is provided. 
  #'
  #'TODO: Check on the missing values for the non-downscaled vars. 
  #'Are they CF-compliant? And if not, how do we deal with the int/double prec. issue?
    
    FUDGEROOT = Sys.getenv(c("FUDGEROOT"))
    
    #Define the time dimension
    #CEW 1-5-2014: now assumed to be an already-existing dimension; 
    #same for xlon and ylat
#     print(is.na(downscale.origin))
#     print(downscale.origin)
#     if (!is.na(downscale.origin)){
#       print("Creating cloned timeseries")
#       time1 <- downscale.tseries
#       tunit <- downscale.origin
#       print(tunit) 
#       print('defining time variable')
#       t1 <- ncdim_def("time",tunit,time1,unlim=TRUE)
#       print(summary(t1))
#     }else{
#       time1 <- time.index.start:time.index.end
#       tunit <- paste('days since ',start.year,'-01-01 12:00:00',sep='')
#       print(tunit) 
#       t1 <- ncdim_def("time",tunit,time1,unlim=TRUE)
#     }
# #    print(time.index.start)
# #    print(time.index.end)
#     print('timesries over')
#     #Define Y
#     y <- ncdim_def("lat","degrees_north",ylat)
#     #Define X
#     if(exists("xlon") & (xlon != '')){
#       x <- ncdim_def("lon","degrees_east",xlon)
#     }
    
    #' If CFNAME undefined in the call, pull information from CF.R. Use default otherwise. 
    print(cfname)
    if(cfname == var.name){
      ###CEW comment: should be sourced from calls in driver script
      #    source(paste(FUDGEROOT,"Rsuite/FudgeIO/src/","CF.R",sep=""))
      cflist <- GetCFName(var.name)
      if(is.list(cflist)){     ###CEW: Changed because was throwing a warning when cflist != "none"
        cfname <- cflist$cfname
        lname <- cflist$cflongname
        print(paste("cfname:",cfname,sep=''))
      }else{
        print("CF.R does not contain this variable. Using default values")
      }
    }
    
    #Define variable list and populate it
    var.dat <- list()
    
    #Write the variable containing downscaled data
    if(exists("xlon") & (xlon != '')){
      var.dat[[var.name]] <- ncvar_def(var.name,units,list(xlon,ylat,downscale.tseries),missval=missval,longname=lname,prec=prec)#x,y,t1
    }else{
      var.dat[[var.name]] <- ncvar_def(var.name,units,list(ylat, downscale.tseries),missval=missval,longname=lname,prec=prec, verbose=TRUE)
    }
    
    #If bounds are present, define bounds and populate bounds variables
    #CEW edit 1-5: Assume being cloned and carried over wholesale from the input data 
#     if(bounds){
#       bnds <- ncdim_def("bnds", "", c(1,2))
#       #If bnds is true, the bounds strucutre will presumably be full of all bnds
#       #presumably gotten from combining the bnds from the first with the bnds from the latter
#       bnds.names <- names(bnds.list)
#       for (i in 1:length(bnds.names)){
#         bnds.var <- bnds.names[i]
#         print(bnds.var)
#         carried.dim <- eval(parse( text=bnds.list[[bnds.var]]$info$dim)) #one of x, y, or t1; 
#         if(!is.null(carried.dim)){ #If a bounds variable                 #see ReadMaskNC for more detail
#           var.dimlist <- list(bnds, carried.dim)
#         }else{  #If an I or J offset
#           var.dimlist=NULL
#         }
#         #correct missing value
#         if (bnds.list[[bnds.var]]$info$prec=="integer"){
#           var.missval=NULL
#         }else{
#          var.missval=1.e20
#        }
#         #Finally, create the non-data variables
#         var.dat[[bnds.var]] <- ncvar_def(bnds.var, 
#                                         units=bnds.list[[bnds.var]]$info$units, 
#                                         dim= var.dimlist, 
#                                         missval = var.missval, 
#                                         longname = bnds.list[[bnds.var]]$info$longname, 
#                                         prec = bnds.list[[bnds.var]]$info$prec)
#       }
#     }
    #1-5 alternate structure
    bnds <- ncdim_def("bnds", "", c(1,2))
    b.len <- as.character(bnds$len)
    x.len <- as.character(xlon$len)
    y.len <- as.character(ylat$len)
    t.len <- as.character(downscale.tseries$len)
    for (v in 1:length(var.data)){
      print(v)
      var <- names(var.data)[v]
      print(paste("defining var", var))
      var.dim <- unlist(strsplit(attr(var.data[[v]], "dimids"), ","))
      print(var.dim)
      var.dimlist <- list()
      #if(is.null(var.dim)){
      if(var.dim=='NA'){
        var.dimlist <- NULL
      }else{
        for(d in 1:length(var.dim)){
          print(d)
          print(var.dim[[d]]) #Blame R's need to return all functions as elements of a list.
          var.dimlist[[d]] <- switch(as.character(var.dim[d]), 
                                     "bnds"=bnds, 
                                     "lon"=xlon, 
                                     "lat"=ylat, 
                                     "time"=downscale.tseries) #There should probably be an error here, but not sure what it would be
        }
      }
      print(paste("number of dimensions for var", var, ":", length(var.dimlist)))
      print(paste("units of var:", attr(var.data[[var]], "units")))
      print(mode(attr(var.data[[var]], "units")))
      var.dat[[var]] <- ncvar_def(var, #var.data[[v]], #Don't forget to add the data in somewhere 
                                  units=attr(var.data[[var]], "units"), #Add check for adding units back in if not present
                                  #units="",
                                  dim=var.dimlist, 
                                  missval=as.numeric(attr(var.data[[var]], "missval") ), #Add check for this as well. 
                                  longname = attr(var.data[[var]], "longname"), 
                                  prec = attr(var.data[[var]], "prec") #This oen gave me hives last time.
                                  )
    }
    print(length(var.dat))
    save('var.dat', file="/home/cew/Code/testing/ncvars.out")
    message("creating nc objects")
    print(filename)
    nc.obj <- nc_create(filename, var.dat)
    print("placing nc vars")
    ncvar_put(nc.obj, var.dat[[var.name]], data.array)
    for (v in 1:length(var.data)){
      loop.var <- names(var.data)[[v]]
      print(paste("adding", loop.var))
      #print(var.dat[[loop.var]])
      ncvar_put(nc.obj, var.dat[[loop.var]], var.data[[loop.var]])
      all.att.list <- attributes(var.data[[loop.var]])
      all.att.list <- all.att.list[!(names(all.att.list)%in% c("units", "missval", "longname", "prec", "dim", "dimids"))]
#       print("attributes to add not in the code:")
#       print(all.att.list)
      if(length(all.att.list) > 0){
        for (at in 1:length(all.att.list)){
          ncatt_put(nc.obj, loop.var,  names(all.att.list)[[at]], all.att.list[[at]])
        }
      }
    }
#     if(bounds){
#       message("Adding variables associated with bounds")
#       bnds.names <- names(bnds.list)
#       for (i in 1:length(bnds.names)){
#         bnds.var <- bnds.names[i]
#         ncvar_put(nc.obj, var.dat[[bnds.var]], bnds.list[[bnds.var]]$vals)
#         #The i_offset and j_offset attributes are very important for the functioning of the output netcdf
#         if(bnds.var=="i_offset" || bnds.var=="j_offset"){
#           ncatt_put(nc.obj, bnds.var, "missing_value", attr(bnds.list[[bnds.var]], "missing_value"))
#           ncatt_put(nc.obj, bnds.var, "comments", attr(bnds.list[[bnds.var]], "comments"))
#         }
#       }
#     }
#     print("placing nc variables")
#     # gets CF mappings from CF.R if user does not pass these 
#     #TODO create grid coordinate bounds variables  
# 
#     #This all might not be needed. See if it throws an error when you run it.
#     # lets make it close to CF compliancy,shall we
# #     ncatt_put(nc.obj,"time","calendar",calendar)
# #     ncatt_put(nc.obj,"time","standard_name","time")
# #     ncatt_put(nc.obj,"time","axis",'T')
# #     ncatt_put(nc.obj,"lat","axis",'Y')
# #     ncatt_put(nc.obj,"lon","axis",'X')
#     if(bounds){
#       #Link bounds variables to the corresponding dims
#       ncatt_put(nc.obj, "lat", 'bounds', 'lat_bnds')
#       ncatt_put(nc.obj, "lon", 'bounds', 'lon_bnds')
#       ncatt_put(nc.obj, "time", 'bounds', 'time_bnds')
#     }
#     ncatt_put(nc.obj,"lat","standard_name","latitude")
#     ncatt_put(nc.obj,"lat","long_name","latitude")
#     ncatt_put(nc.obj,"lon","standard_name","longitude")
#     ncatt_put(nc.obj,"lon","long_name","longitude")
    ncatt_put(nc.obj,var.dat[[var.name]],"units",units)
    ncatt_put(nc.obj,var.dat[[var.name]],"standard_name",cfname)
    ########### write grid coordinate bounds ####################
    
    #############################################################  
    nc_close(nc.obj)
    return(filename)
}
