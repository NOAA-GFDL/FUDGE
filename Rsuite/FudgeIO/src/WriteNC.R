# Aparna Radhakrishnan 08/04/2014
WriteNC <-  function(filename,data.array,var.name,xlon,ylat, time.index.start=0, time.index.end=1, downscale.tseries=NA, downscale.origin=NA,
                     start.year="undefined",units ,calendar,lname=var.name,cfname=var.name, 
                     bnds=FALSE, bnds.list=NA) {
  #'Creates file filename (netCDF type) with the variable  var.name along with the 
  #'coordinate variables in the netCDF file, CF standard name, long names.
  #'
  #'@param filename: The name under which the data will be written
  #' -----Parameters related to the NetCDF varaible-----
  #'@param data.array: The array containing the values of the variable to 
  #'be written to file. 
  #'@param var.name: The short name of the NetCDF variable being written. In the
  #'current FUDGE driver, generated by ****
  #'@param units: The units of the NetCDF variable. In the current FUDGE driver, 
  #'obtained by CFChecker
  #'@param lname: The long name of the NetCDF variable being written. In the current 
  #'FUDGE driver, generated by ****
  #'@param cfname: The CF-standard-compliant name of the variable being written.
  #'Currently obtained from (), and defaults to var.name.
  #' ------Parameters related to the dimensions of the new NetCDF file----
  #'Note: at present, all time-related coordinates are obtained from the 
  #'time windowing mask file specified as the future predictor, and all 
  #'space-related coordinates are obtained from the spatial mask specified
  #'for the region.
  #'@param xlon, ylat : The longitude and latitude coordinates of the data
  #'being written, in degrees east and degrees north respectively.  
  #'  --Useg to get time data directly from the time masks:
  #'@param downscale.tseries: The vector representing the timeseries of the 
  #'file in 'days since' downscale.origin format. 
  #'@param downscale.origin: The origin from which downscale.tseries is calculated,
  #'in 'days since..." format. 
  #'@param calendar: The calendar of the timeseries.
  #' --Used to construct time data from the inputs
  #'@param start.year: Altername method for determining the origin 
  #'@param time.index.start: first time index from which to count. Defaults to 0.
  #'@param time.index.end: time index to count to. Defaults to 1. 
  #'
    
    FUDGEROOT = Sys.getenv(c("FUDGEROOT"))
    
    #Define the time dimension
    if (!is.na(downscale.origin)){
      time1 <- downscale.tseries
      tunit <- downscale.origin
      print(tunit) 
      t1 <- ncdim_def("time",tunit,time1,unlim=TRUE)
    }else{
      time1 <- time.index.start:time.index.end
      tunit <- paste('days since ',start.year,'-01-01 12:00:00',sep='')
      print(tunit) 
      t1 <- ncdim_def("time",tunit,time1,unlim=TRUE)
    }
    
    #Define Y
    y <- ncdim_def("lat","degrees_north",ylat)
    #Define X
    if(exists("xlon") & (xlon != '')){
      x <- ncdim_def("lon","degrees_east",xlon)
    }
    
    #' If CFNAME undefined in the call, pull information from CF.R. Use default otherwise. 
    print(cfname)
    if(cfname == var.name){
      ###CEW comment: should be sourced from calls in driver script
      #    source(paste(FUDGEROOT,"Rsuite/FudgeIO/src/","CF.R",sep=""))
      cflist <- GetCFName(var.name)
      if(is.list(cflist)){     ###CEW: Changed because was throwing a warning when cflist != "none"
        cfname <- cflist$cfname
        lname <- cflist$cflongname
        print(paste("cfname:",cfname,sep=''))
      }else{
        print("CF.R does not contain this variable. Using default values")
      }
    }
    
    #Define variable list and populate it
    var.dat <- list()
    
    if(exists("xlon") & (xlon != '')){
      var.dat[var.name] <- ncvar_def(var.name,units,list(x,y,t1),1.e20,longname=lname,prec="double")
    }else{
      var.dat[var.name] <- ncvar_def(var.name,units,list(y,t1),1.e20,longname=lname,prec="double")
    }
    #If bounds are present, define bounds and populate bounds variables
    if(bnds){
      bounds <- ncdim_def("bnds", "", c(1,2))
      #If bnds is true, the bounds strucutre will presumably be full of all bnds
      bnds.names <- names(bnds.list)
      for (bnd in 1:length(bnds.names)){
        varname <- bnds.names[bnd]
      }
    }
    
    print("creating nc objects")
    nc.obj <- nc_create(filename,var.dat)
    print("placing nc vars")
    ncvar_put(nc.obj, var.dat, data.array)
    print("placing nc variables")
    # gets CF mappings from CF.R if user does not pass these 
    #TODO create grid coordinate bounds variables  
    
    # lets make it close to CF compliancy,shall we
    ncatt_put(nc.obj,"time","calendar",calendar)
    ncatt_put(nc.obj,"time","standard_name","time")
    ncatt_put(nc.obj,"time","axis",'T')
    ncatt_put(nc.obj,"lat","axis",'Y')
    ncatt_put(nc.obj,"lon","axis",'X')
    ncatt_put(nc.obj,"lat","standard_name","latitude")
    ncatt_put(nc.obj,"lat","long_name","latitude")
    ncatt_put(nc.obj,"lon","standard_name","longitude")
    ncatt_put(nc.obj,"lon","long_name","longitude")
    ncatt_put(nc.obj,var.dat,"units",units)
    ncatt_put(nc.obj,var.dat,"standard_name",cfname)
    ########### write grid coordinate bounds ####################
    
    #############################################################  
    nc_close(nc.obj)
    return(filename)
}
