# Aparna Radhakrishnan 08/04/2014
WriteNC <-  function(filename,data.array,var.name,xlon,ylat,prec='double', missval=1.e20,
                     time.index.start=NA, time.index.end=NA, downscale.tseries=NA, downscale.origin=NA,
                     start.year="undefined",units ,calendar,lname=var.name,cfname=var.name, 
                     bounds=FALSE, bnds.list=NA) {
  #'Creates file filename (netCDF type) with the variable  var.name along with the 
  #'coordinate variables in the netCDF file, CF standard name, long names.
  #'
  #'@param filename: The name under which the data will be written
  #' -----Parameters related to the NetCDF varaible-----
  #'@param data.array: The array containing the values of the variable to 
  #'be written to file. 
  #'@param var.name: The short name of the NetCDF variable being written. In the
  #'current FUDGE driver, picked up from the input var list.
  #'@param units: The units of the NetCDF variable. In the current FUDGE driver, 
  #'obtained by CFChecker
  #'@param lname: The long name of the NetCDF variable being written. In the current 
  #'FUDGE driver, generated by CF.R
  #'@param cfname: The CF-standard-compliant name of the variable being written.
  #'Currently obtained from CF.R, and defaults to var.name.
  #' ------Parameters related to the dimensions of the new NetCDF file----
  #'Note: at present, all time-related coordinates are obtained from the 
  #'time windowing mask file specified as the future predictor, and all 
  #'space-related coordinates are obtained from the spatial mask specified
  #'for the region.
  #'@param xlon, ylat : The longitude and latitude coordinates of the data
  #'being written, in degrees east and degrees north respectively.  
  #'  --Useg to get time data directly from the time masks:
  #'@param downscale.tseries: The vector representing the timeseries of the 
  #'file in 'days since' downscale.origin format. 
  #'@param downscale.origin: The origin from which downscale.tseries is calculated,
  #'in 'days since..." format. 
  #'@param calendar: The calendar of the timeseries.
  #' --Used to construct time data from the inputs
  #'@param start.year: Altername method for determining the origin 
  #'@param time.index.start: first time index from which to count. Defaults to 0.
  #'@param time.index.end: time index to count to. Defaults to 1. 
  #'--Used to create the bounds variables and offsets 
  #'--(neccesary if to be looked at in Ferret)
  #'@param bounds=FALSE: Whether or not to attempt consruction of bounds parameters. 
  #'Defaults to FALSE.
  #'@param bnds.list=NA : The list of bounds values and other parameters to be used
  #'in constructing a variable. Currently cloned from the input mask files; defaults to 
  #'NA if no list is provided. 
  #'
  #'TODO: Check on the missing values for the non-downscaled vars. 
  #'Are they CF-compliant? And if not, how do we deal with the int/double prec. issue?
    
    FUDGEROOT = Sys.getenv(c("FUDGEROOT"))
    
    #Define the time dimension
    print(is.na(downscale.origin))
    print(downscale.origin)
    if (!is.na(downscale.origin)){
      print("Creating cloned timeseries")
      time1 <- downscale.tseries
      tunit <- downscale.origin
      print(tunit) 
      print('defining time variable')
      t1 <- ncdim_def("time",tunit,time1,unlim=TRUE)
      print(summary(t1))
    }else{
      time1 <- time.index.start:time.index.end
      tunit <- paste('days since ',start.year,'-01-01 12:00:00',sep='')
      print(tunit) 
      t1 <- ncdim_def("time",tunit,time1,unlim=TRUE)
    }
#    print(time.index.start)
#    print(time.index.end)
    print('timesries over')
    #Define Y
    y <- ncdim_def("lat","degrees_north",ylat)
    #Define X
    if(exists("xlon") & (xlon != '')){
      x <- ncdim_def("lon","degrees_east",xlon)
    }
    
    #' If CFNAME undefined in the call, pull information from CF.R. Use default otherwise. 
    print(cfname)
    if(cfname == var.name){
      ###CEW comment: should be sourced from calls in driver script
      #    source(paste(FUDGEROOT,"Rsuite/FudgeIO/src/","CF.R",sep=""))
      cflist <- GetCFName(var.name)
      if(is.list(cflist)){     ###CEW: Changed because was throwing a warning when cflist != "none"
        cfname <- cflist$cfname
        lname <- cflist$cflongname
        print(paste("cfname:",cfname,sep=''))
      }else{
        print("CF.R does not contain this variable. Using default values")
      }
    }
    
    #Define variable list and populate it
    var.dat <- list()
    
    #Write the variable containing downscaled data
    if(exists("xlon") & (xlon != '')){
      var.dat[[var.name]] <- ncvar_def(var.name,units,list(x,y,t1),missval=missval,longname=lname,prec=prec)
    }else{
      var.dat[[var.name]] <- ncvar_def(var.name,units,list(y,t1),missval=missval,longname=lname,prec=prec, verbose=TRUE)
    }
    
    #If bounds are present, define bounds and populate bounds variables
    if(bounds){
      bnds <- ncdim_def("bnds", "", c(1,2))
      #If bnds is true, the bounds strucutre will presumably be full of all bnds
      #presumably gotten from combining the bnds from the first with the bnds from the latter
      bnds.names <- names(bnds.list)
      for (i in 1:length(bnds.names)){
        bnds.var <- bnds.names[i]
        print(bnds.var)
        carried.dim <- eval(parse( text=bnds.list[[bnds.var]]$info$dim)) #one of x, y, or t1; 
        if(!is.null(carried.dim)){ #If a bounds variable                 #see ReadMaskNC for more detail
          var.dimlist <- list(bnds, carried.dim)
        }else{  #If an I or J offset
          var.dimlist=NULL
        }
        #correct missing value
        if (bnds.list[[bnds.var]]$info$prec=="integer"){
          var.missval=NULL
        }else{
         var.missval=1.e20
       }
        #Finally, create the non-data variables
        var.dat[[bnds.var]] <- ncvar_def(bnds.var, 
                                        units=bnds.list[[bnds.var]]$info$units, 
                                        dim= var.dimlist, 
                                        missval = var.missval, 
                                        longname = bnds.list[[bnds.var]]$info$longname, 
                                        prec = bnds.list[[bnds.var]]$info$prec)
      }
    }
    #save('var.dat', file="/home/cew/Code/testing/ncvars.out")
    message("creating nc objects")
    nc.obj <- nc_create(filename,var.dat)
    print("placing nc vars")
    ncvar_put(nc.obj, var.dat[[var.name]], data.array)
    if(bounds){
      message("Adding variables associated with bounds")
      bnds.names <- names(bnds.list)
      for (i in 1:length(bnds.names)){
        bnds.var <- bnds.names[i]
        ncvar_put(nc.obj, var.dat[[bnds.var]], bnds.list[[bnds.var]]$vals)
        #The i_offset and j_offset attributes are very important for the functioning of the output netcdf
        if(bnds.var=="i_offset" || bnds.var=="j_offset"){
          ncatt_put(nc.obj, bnds.var, "missing_value", attr(bnds.list[[bnds.var]], "missing_value"))
          ncatt_put(nc.obj, bnds.var, "comments", attr(bnds.list[[bnds.var]], "comments"))
        }
      }
    }
    print("placing nc variables")
    # gets CF mappings from CF.R if user does not pass these 
    #TODO create grid coordinate bounds variables  
    
    # lets make it close to CF compliancy,shall we
    ncatt_put(nc.obj,"time","calendar",calendar)
    ncatt_put(nc.obj,"time","standard_name","time")
    ncatt_put(nc.obj,"time","axis",'T')
    ncatt_put(nc.obj,"lat","axis",'Y')
    ncatt_put(nc.obj,"lon","axis",'X')
    if(bounds){
      #Link bounds variables to the corresponding dims
      ncatt_put(nc.obj, "lat", 'bounds', 'lat_bnds')
      ncatt_put(nc.obj, "lon", 'bounds', 'lon_bnds')
      ncatt_put(nc.obj, "time", 'bounds', 'time_bnds')
    }
    ncatt_put(nc.obj,"lat","standard_name","latitude")
    ncatt_put(nc.obj,"lat","long_name","latitude")
    ncatt_put(nc.obj,"lon","standard_name","longitude")
    ncatt_put(nc.obj,"lon","long_name","longitude")
    ncatt_put(nc.obj,var.dat[[var.name]],"units",units)
    ncatt_put(nc.obj,var.dat[[var.name]],"standard_name",cfname)
    ########### write grid coordinate bounds ####################
    
    #############################################################  
    nc_close(nc.obj)
    return(filename)
}
