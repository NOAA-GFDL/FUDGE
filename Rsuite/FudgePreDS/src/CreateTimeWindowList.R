#CreateTimeWindowList.R
#'Reads in time masks and performs basic QC, including checks between the masks
#'to make sure there are the same number of masks per file.
#' @param hist.train.mask: path to file with the masks for historical predictors
#' @param hist.targ.mask: path to file with the masks for target data 
#' @param esd.gen.mask: Mask to apply to the esdgen datasets. Needs to be checked
#' for overlapping masks as well. 
#' @param method="generic": The method included, if it will change the checks that need to
#' be performed on the intial data. CDFt, for example, currently has a check for 
#' overlapping masks on all predictors
#' @return A list containing (in this version) three elements (one for the hist.train,
#' hist.targ and fut.train), each containing the timeseries associated with each mask 
#' (used in cross-validation) and the named masks contained within the file. 
#' @example insert example here
#' @references \url{link to the FUDGE API documentation}
#' TODO: set function to perform checks for more than one esdgen dataset
#' TODO: Is there a good way to preallocate lists for speeed in this place?
#' TODO: Develop better mask comparison when more than one mask is present


CreateTimeWindowList <- function(hist.train.mask, hist.targ.mask, esd.gen.mask, k=0, method="generic", time.prune.mask=NA){

  #This is the list of methods that use all arguments in order to generate the esd
  #equations, and therefore should probably be run without
  #overlapping time windows
  if (!train.and.use.same){   #If method uses only historical data to generate eq's
    message("Obtaining all time masks")
    t.pred.masks <- QCTimeMask(ReadMaskNC(nc_open(hist.train.mask)))
    t.targ.masks <- QCTimeMask(ReadMaskNC(nc_open(hist.targ.mask)))
    esd.gen.masks <- QCTimeMask(ReadMaskNC(nc_open(esd.gen.mask), get.bounds.vars=FALSE), run=TRUE)
  }else{                          #If method uses historic and future data to generate eq's
    message("Obtaining all time masks")
    if(!is.na(time.prune.mask)){
      t.pred.masks <- QCTimeMask(ReadMaskNC(nc_open(hist.train.mask)))
      t.targ.masks <- QCTimeMask(ReadMaskNC(nc_open(hist.targ.mask)))
      esd.gen.masks <- QCTimeMask(ReadMaskNC(nc_open(esd.gen.mask)))
      message("Obtaining time pruning mask")
      time.prune.mask <- QCTimeMask(ReadMaskNC(nc_open(time.prune.mask), get.bounds.vars=FALSE), run=TRUE)
      message('creating final list')
      return(list(t.pred.masks, t.targ.masks, esd.gen.masks, time.prune.mask))
    }
    t.pred.masks <- QCTimeMask(ReadMaskNC(nc_open(hist.train.mask)), run=TRUE)
    t.targ.masks <- QCTimeMask(ReadMaskNC(nc_open(hist.targ.mask)), run=TRUE)
    esd.gen.masks <- QCTimeMask(ReadMaskNC(nc_open(esd.gen.mask), get.bounds.vars=FALSE), run=TRUE)
  }
  message("Creating final list")
  #tmask.list <- list("train.pred" = t.pred.masks, "train.targ" = t.targ.masks, "esd.gen" = esd.gen.masks)
  tmask.list <- list(t.pred.masks, t.targ.masks, esd.gen.masks)
  return(tmask.list)
}



#Removes anything that might not be a data variable from a list of 
#names generated by names(thisnc$var)
#I know, it's barely a function; however, it does mean it's easy
#to chain on more conditionals as things progress. And it gets used
#twice.
RemoveBounds<-function(names){
  return(names[names!="lon_bnds"&names!="lat_bnds"&names!="time_bnds"&
                 names!="i_offset"&names!="j_offset"&names!="height"])
}



# CheckJulian <- function(calendar, timeseries, origin){
#   #Checks to see whether or not the Julian calendar
#   #is supported over the date range, and returns
#   #the converted time series if that is the case.
#   time.origin <- as.PCICt(origin, 'gregorian')
#   startdate <- time.origin + timeseries[1]*86400
#   enddate <- time.origin + timeseries[length(timeseries)]*86400
#   if (startdate >= as.PCICt("1900-01-01 0:00:00","gregorian") && 
#         enddate <= as.PCICt("2099-12-31 23:59:59", "gregorian")){
#     return(time.origin + timeseries * 86400)
#   }else{
#     warning(paste("Julian calendar error: PCICt does not support", 
#                "the Julian calendar over range", startdate,"to",enddate))
#   }
# }
