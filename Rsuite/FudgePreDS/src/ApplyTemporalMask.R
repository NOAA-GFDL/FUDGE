#'Applies temporal masks to a 3-dimensional dataset (x, y, time).
#'At some point in the future, mask should be able to be a) a timeseries of the same
#'length, b) a shorter (365-day) timseries, c) a longer, subsettable timeseries.
#'For now, it should be enough to get the 
#' @param data: a 3-dimensional dataset with final dimension representing time
#' @param masknc: a path to an existing ncdf file containing one or more temporal
#' masks of the same dimensions as the data being masked
#' @param timeData: A timeseries imported from the source ncdf file of data, where 
#' @param maskname: An optional parameter describing which variable within masknc should be used
#' for masking. If not specified, the script will loop over all available mask variables within the 
#' masknc file, and return a list of all masked data.
#' @param type: an optional string specifying the use of the masks. If type=="run", masks will be checked for 
#' overlap.
#' @param maskAll: an optional boolean describing whether or not to check, when type=="run", if the masks
#' cover the entire series or not. Defaults to TRUE (raises an error if not covering entire series).
#' @return Either a 3-dimensional array of the same dimensions as the input data, with all time coordiantes where
#' the mask contained a "NA" replaced with a "NA" (if maskname is supplied), or a list of 1-dimensional arrays of the
#' sam length as data, with all other properties as described above (dimensions don't agree with lists in this case.)
#' @example insert example here
#' @references \url{link to the FUDGE API documentation}
#'  
ApplyTemporalMask<-function(data, masknc, timeData, maskname="none", type="train"){ # maskAll==TRUE
  library(abind)
  start_time<-proc.time()
  data.length<-length(data)
  thisnc<-nc_open(masknc)
  #Assume that calendar for all masks and data was checked earlier, with the CheckCalendar utility
  if ( (thisnc$dim$time$vals[[1]]!=timeData[[1]]) | ( length(thisnc$dim$time$vals) != length(timeData) ) ){
    stop(paste("Time dimension error: Data had ititial time value of", timeData[[1]], "and length of", length(timeData),
               "while mask had initital time value of", thisnc$time$vals[[1]], "and length of", length(thisnc$dim$time$vals)))
  }
  if (maskname!="none"){
    mask.data<-ncvar_get(thisnc, maskname) #Check for dimensional correspondence 
    if (!( length(mask.data)==length(data[1,1,]) ) ){
      stop(paste("Temporal mask dimension error: mask was of length", length(mask.data), 
                 "and was expected to be of length", length(data[1,1,])))
    }else{
      tempvar <- abind(lapply(1:dim(data)[3], function(i) data[,,i] * mask.data[[i]]),along=3) #Lapply or sapply? Does it make a diff?
      dim(tempvar)<-dim(data)
      mask.out<-list(tempvar)
      names(mask.out)<-maskname
      return(mask.out) #Check to make sure this works
    }
  }else{
    #grab all vars from the file and apply them
    mask.names <- RemoveBounds(names(thisnc$var)) #Remove anything that's not a mask
    mask.out<-vector(mode="list",length=length(mask.names))
    tempvar<-vector(mode="list", length=data.length)
    NA.storage.vector<-rep(0,data.length)
    for (name in 1:length(mask.names)){
      mask.data<-ncvar_get(thisnc, mask.names[name])#obtain masked data
      print(paste("Starting on loop", name, "of", length(mask.names)))
      NA.storage.vector<-NA.storage.vector+convert.NAs(mask.data)  #store location of NAs for error checking
      if (!length(mask.data)==length(data[1,1,])){
        stop(paste("Temporal mask dimension error: mask", masknc, mask.names[name], "was of length", length(mask.data), 
                   "and was expected to be of length", length(data[1,1,])))
      }
      if (type=="run" && ( max(NA.storage.vector) > 1) ){  #tot.not.NAs >= data.length ||
        stop(paste("Mask collision error: Masks within", masknc
                   ,",provided as ESD downscaling mask file, either overlap or do not wholly cover the timeseries."))
      }
      tempvar <- abind(lapply(1:dim(data)[3], function(i) data[,,i] * mask.data[[i]]),along=2) #along=3
      dim(tempvar)<-dim(data)
      mask.out[[name]]<-tempvar
    }
    names(mask.out)<-mask.names
  }
  return(mask.out)
}

#Removes anything that might not be a data variable from a list of 
#names generated by names(thisnc$var)
#I know, it's barely a function; however, it does mean it's easy
#to chain on more conditionals as things progress. And it gets used
#twice.
RemoveBounds<-function(names){
  return(names[names!="lon_bnds"&names!="lat_bnds"&names!="time_bnds"&names!="i_offset"&names!="j_offset"])
}

#Converts NAs to 0, and all non-NA values to 1
#and returns the result in a 1-D form
convert.NAs<-function(dataset){
  dataset2<-dataset
  dataset2[is.na(dataset)]<-0
  dataset2[!is.na(dataset)]<-1
  return(as.vector(dataset2))
}